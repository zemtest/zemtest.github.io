---
layout: entry
title: "컴보 시험대비 빠샤"
author: 이제언
date: 2017-06-11 17:05 +0900
tags: 컴퓨터보안, 보안, 기말고사
comments: true
--- 
* table of contents
{:toc}


```  
마지막 수업 때, 시험 언급내용...  

만약 마지막 수업에서 낸다면..?  
-> 폴리몰틱 인크립티드 바이러스 메타월픽

제일 중요한건 프로토콜이다

커버러스.. 토큰으로 어떻게 인증되고 어떻게 정보가 안전하게 상호인증이 되면서 .....  
이런 프로토콜을 하나하나 해설을 할 수 있어야 하고, 조그마한걸 만들 수 있을 정도로 알아야 한다.  

타임스탬프, 넌스가 어떤뜻인지... 인증서 기반 도대체 저게 뭐하는건지?..  

서명..검증.. 저게 도대체 뭔지?!  

공개키 기반으로 했을 때, private / public 특성이 있더라.(각각이 뭘 하는지?)  

해쉬! One-way ness? 특성이 어디서 나오는지?  

해쉬 이용해서 고결성만 제공됐는데, 키 값이 들어가면 <인증>을 할 수 있더라!  
>> 메세지에 대한 무결성을... + source에 대한 Originality..!까지 보장하는 뭔가가 있었죠? 그쵸? ㅅㅂ  

엘가말 증명해봐라  
```

# CH10.1 Key Management other PKC

## RSA

### Review

일반적으로 암호화 할 때, sender, receiver가 같은 key를 공유했었다.

이렇게 되면, 두 사람이 key를 분배하는 과정에서 n명이 각각 서로 카톡방(?)을 가져야 하기 때문에 **nC2** 개 만큼 key가 필요했다.

그래서, **공개키 알고리즘**을 사용하기로 한다.



1. 두 소수 p, q를 선정한다.  
2. p, q를 통해 n = p x q라는 값을 갖게된다.  
3. phi(n) = (p-1) x (q-1) 값을 갖는다.  
4. gcd( e, phi(n) ) = 1인 e 값을 선정하여 공개키로 설정한다.  
5. d x e = 1 (mod phi(n))인 d를 구한다.

위 과정을 통해 PU = {e, n}, PR = {p, q, d}가 설정된다.

### 메세지 암호화, 복호화  
CipherText = Message^{e} mod n.  
공개키 e, n을 통해 아무 메시지나 암호화해서 보낼 수 있다.  

Message = CiperText^{d} mod n.  
비밀키 d를 통해 비밀 메시지를 풀 수 있다.



## 키 분배(관리)

키 분배(관리)에는 4가지 방법이 있다.

### Public Announcement  
그냥 다른 사람들에게 자신의 key를 알리는 방법이다.  
위조에 취약함.(ex. 저 제언인데요, 100만원만 빌려주세요^^)

### Public Available Directory  
게시판 같은 열린 공간에 자신의 공개키를 올리는 방법이다.  
이 방법은 홈페이지가 공격당하면 GG...

### Public-key Authority  
Public-key Authority(기관)이 공개키를 관리해주는 방식이다.  
A와 B가 통신하기 위해 아래의 과정을 거쳐야한다.

1. A가 기관에게 B의 공개키를 요구한다.  
(A->PA) Request || TimeStamp1  
2. 기관이 A에게 공개키를 서명해서 준다.  
(PA->A) E(PR_{auth} [ PU_{b} || Request || TimeStamp1 ])

3. A가 B의 공개키로 자신의 아이디와 Nonce를 실어 보낸다.  
(A->B) E(PU_{b}, [ID_{A} || Nonce1])

4. B도 기관에게 1, 2의 과정을 거쳐 A의 공개키를 얻는다.(식 생략)

5. B가 A의 공개키로 받은 Nonce와 새로운 Nonce를 생성하여 보낸다.
(B->A) E(PU_{a}, [N1 || N2])  
이 과정에서 B의 공개키로 암호화 된 N1을 해독하고 다시 보내주는 과정을 통해 **상호 인증**이 된다.

6. A가 B에게 잘 받았다고 B가 생성한 N2를 재 전송한다.(**상호인증**)  
(A->B) E(PU_{b}, N2)  

이 프로토콜은 확인할 때 마다 TimeStamp를 변경하면서 계속해서 요청하는 방식이기 때문에 **병목현상**을 일으킬 수 있다.

### Public-Key Certificates

확인하는 기관에서 인증서 자체를 줘 버리는 방식.  
인증서 = {신원, 공개키}를 기관이 서명해 주는 방식.  
자세한 내용은 아래에서 다루겠다.


### Simple Secret Key Distribution(Ks분배)

Merkle에 의해 고안된 방식이다.  
암호화 없이 공개키와 신원을 보내면, 그 공개키를 받은 사람이 Ks를 주는 방식.
   
(A->B) [ PU_{a} || ID_{A} ]  
(B->A) E(PU_{a}, Ks)

딱! 봐도 알겠지만, A->B 보내는 도중에 다른 사람이 낚아채는 위험이 있다.  
**Man-in-the-Middle-Attack**

(A->Z) [ PU_{a} || ID_{A} ]  
(Z->B) [ PU_{z] || IA_{A} ] // 이 과정에서 A인척 자신의 공개키를 준다.  
(B->Z) E(PU_{z}, Ks)  
(Z->A) E(PU_{a}, Ks)  

이렇게 되면 A, B는 각각 메시지를 정상적으로 받지만 3명이 Ks를 분배하는 결과를 낳게 된다.

### Secret-Key Distribution with Confidentiality & Authentication

각각 상대의 공개키로 암호화한 메시지를 보내고, 메시지에는 Nonce가 포함된다!!

(A->B) E(PU_{b}, [N1 || ID_{A}])  
(B->A) E(PU_{a}, [N1 || N2])  
(A->B) E(PU_{b}, N2)  
(A->B) E(PU_{b}, E(PR_{a}, Ks))

마지막 과정에서 Ks를 A가 자신의 비밀키로 서명하여, Man-in-the-Middle-Attack을 방지한다.  
마지막 과정에서 PU_{b}로 암호화 하는 것은 **기밀성**방지, PR_{a}로 암호화 하는 것은 **서명(인증)**을 위함!! 

### Hybrid Key Distribution

자세히 안다룬내용.

## ★ Diffie-Hellman Key Exchange

암호 Key(Session key)를 교환하는 하나의 방법.  
Discrete Logarithm Problem 기반 프로토콜.  

**사용 변수**  
	(공개) 큰 소수 *p*  
	(공개) 임의의 수 *g* (Generalization)  
	(비밀) A가 만드는 임의의 수 *a(YA)*  
	(비밀) B가 만드는 임의의 수 *b(YB)*  
	(비밀) a, b(YA, YB)로 계산할 수 있는 Secret key *S*

**교환하는 과정**

1. A와 B는 소수 **p**, 임의의 generalization **g**를 사용하기로 한다.  
	이해를 돕기 위해, p = 23, g = 5로 가정한다.

2. A가 임의의 수 a = 6을 선택한 후, YA를 B에게 전송한다. (YA = g^{a} mod p)  
	(A->B) YA.

3. B는 임의의 수 b = 15를 선택한 후, YB를 A에게 전송한다. (YB = g^{b} mod p)  
	(B->A) YB.

4. A, B는 각각 받은 수 YA, YB를 통해 Secret Key를 계산한다.  
	(**S** = **YA^{b} mod p** = **YB^{a} mod p**)

5. A와 B는 각각 Secret Key **S**를 공유하게 되었다.

단, 디피헬만 키분배는 **인증 과정이 없기 때문에** Man-in-the-Middle-Attack에 취약하다.  
(교환 알고리즘 자체는 암호학적으로 안정적임)

이 중간자 공격을 막기 위해 디피헬만 알고리즘 위에 다른 알고리즘을 섞어 사용한다.

## ElGamal Cryptography

Discrete Logarithm Problem 기반.  

엘가말 기반이라 엘가말 키 교환이랑 비슷함!!  

### 키 생성

1. 큰 소수 q를 선택하고, 생성자 g를 선택한다.  
2. 비밀키 x를 선택하고, 공개키 y를 계산한다.  
   (y = g^{x} mod q)  
3. {y, g, q}는 공개키, {x}는 비밀키가 된다.

### 메세지 암호화

1. 메세지 M을 암호화하기 위해 난수 k를 선택한다. (**일회성**)  
2. 난수 k로 One-Time Key인 K를 계산한다.  
   (K = y^{k} mod q)  
   (K는 풀어보면 g^{x * k} mod q가 된다)  
3. 암호문을 계산한다.  
   C1 = g^{k} mod q  
   C2 = K * M mod q  
4. (C1, C2)를 수신자에게 전달한다.

### 메세지 복호화

서로 미리 교환한 x값과 전달받은 C1, C2 값으로 받은 메세지를 복호화 해보자.  

1. One-Time-Key K를 C1을 통해 복호화한다.  
K = y^{k} mod q  
  = a^{k*x} mod q  
  = **C1^{x} mod q**

2. Message M을 C2와 계산한 K를 통해 복호화한다.  
M = C2 * K^{-1} mod q  
(K의 inverse 계산)

### 엘가말의 뽀인뜨

* 장점  
> 매 교환시 난수 k를 이용하므로 안전하다.  
> (같은 M, 같은 키를 사용해도 암호화 할때마다 변하기 때문)

* 단점  
> Message M을 암호화 할 때, 길이가 두 배로 늘어난다....(흑흑)

---

# CH10.2 ECC (Elliptic Curve Cryptography)

딴거 먼저 하고 이거 공부할 예정 ㅠㅠ

---  

# CH11 MAC & Hash

## 개요

메세지에 대한 인증(Message Athentication)은 크게 두 가지로 나뉜다.  
1) 보낸 메세지가 위조/변조되지 않았는가? 
2) 발신자에 대한 신원 확인(A가 맞는가?)  
3) 부정 방지(해 놓고 안했다 하기 없기)  

위 내용을 방지하기 위해 세 가지 function을 사용할 것이다.  
1. Message Encryption  
2. Message Authentication Code(MAC)  
3. hash function  

## Message Encryption

*Problem of public-key*  
public-key encryption을 사용하게 되면 **발신자에 대한 신원확인**이 어렵게 된다.(모두가 공개키를 알 수 있기 때문)  

*Solution*  
> 발신자가 메시지를 자신의 Private-key로 서명.  
> **비밀보장** 및 **인증**이 동시에 해결!!  

*But*  
암호화 하는데 비용이 들더라..  

## Message Authentication Code(MAC)

MAC은 메세지의 무결성 확인 및 인증을 위한 Code를 달아주는 방식이다.

**Sender**

....*input*  
Message, K(공유하는 key)  

....*전송하는 정보*  
Message와 MAC Code  

**Receiver**  

1. 메세지를 일단 받는다.  
2. 메세지를 같은 K값으로 MAC Algorithm을 거쳐 MAC Code를 얻는다.  
3. 받은 MAC과 일치하는지 확인한다.  

그림으로 이해하면 아래와 같다.  
![Message_Authentication_Code](https://zemalee.github.io/images/Computer_Security/01_Message_Athentication_Code.png)  

....*참고*  
MAC은 기본적으로 Many-to-One 함수이기 때문에, 같은 결과를 내는 입력이 여러개일 수 있다.  
따라서, MAC 알고리즘은 동일한 MAC값을 가진 Message를 찾는 것이 infeasible 해야 한다.   

MAC기반 DES-CBC 대표적인 알고리즘  
(**DAA**: Data Authentication Algorithm)  
Block-Chaining 방식 예제라네요..  
MAC이랑 연관됐는진 모르겠지만 눈에 익히기 위해...   
![Data Authentication Algorithm](https://zemalee.github.io/images/Computer_Security/02_Data_Authentication_Algorithm.png)  


## Hash Function

h = Hash( M )이라고 가정하고, MAC과 비슷한 동작을 함.  

A가 자기 private-key로 서명한 Hash 내용을 메세지에 붙여 전송하는 그림.  
![Hashing](https://zemalee.github.io/images/Computer_Security/03_Hashing.png)  

MAC과 비슷하게, 수신자도 Hash(M)을 한 번 수행하면 된다. 

*참고사항*  
h = H(x)라고 할 때,  
같은 h값을 갖는 x값이 여러개일 수 있기 때문에 보낸 진짜 내용을 찾기가 어렵다. 이를 One-way-function이라고 부른다.  
Collision이 일어날 확률이 매우 적다.  
(H(x)=H(y)가 될 확률이 적다)  
반대로 생각하면, 같은 해쉬값을 갖는 M을 찾기 힘들다.  

**요약**) M으로 h를 만들기는 쉽지만 h로 M을 찾기 어렵게 하는, 짧게 만들어 주는 해쉬함수!  

## Security of Hash Functions & MACs

**Birthday Paradox**  
Hash 충돌과 관련된 내용.  
365일 중, 같은 생일을 가진사람을 뽑을 확률이 23명이면 50%, 80명이면 거의 100% 뽑는다는 내용.  

결론만 적도록 하겠다.
Hash가 n bit라고 할 때, 1.17 * 루트 n을 취한만큼만 시도하면 충돌이 일어날 확률이 50%더라...  

---  

# CH12 MIC & SHA

## Classification of Hash Functions

MAC이라는 단어를 네트워크에서 하도 많이써서;;; 용어를 정리하도록 한다.  

Hash 함수를 목적에 따라 나눌 수 있다.  

* **MDC** = **MIC**  
수정여부를 검사하는 Code를 갖는 Hash.  
(MDC : Modification Detection Codes)  
(MIC : Message Integrity Codes)  
Key가 필요없다. **Unkeyed**  
같은 알고리즘을 사용하면 **같은 입력에 대해 항상 같은 출력을 갖는다.**  


```  
(농담)  
M : 모디파이 됐는지~  
D : 디텍션하는  
C : 코드  
```  

* **MAC**  
인증을 위한 Code를 갖는 Hash.
(MAC : Message Authentication Codes)  
Key가 항상 있어야 한다. **Keyed**  
같은 알고리즘을 사용해도 **Key에 따라 출력이 달라진다.**  

## UnKeyed Hash Functions - SHA

SHA : Secure Hash Algorithm  
160비트짜리를 SHA-1이라고 부른다.  
중국인 여자 교수 WANG이 치명적 단점을 밝힌 그 알고리즘..  

이후, SHA-256, 384, 512를 개발함.  

SHA-512만 간단하게 요약해보겠다.  
1. 메세지 Panding  
	메세지 길이를 1024의 배수로 맞추기 위해 Pending한다.  
2. 길이 정보 추가  
3. 해쉬 버퍼 초기화  
4. 1024 비트 처리  
5. 출력  

어려우니 그림으로 보자

![Message Pending](https://zemalee.github.io/images/Computer_Security/04_SHA1024_01.png)  

우선, 메세지 길이를 1024비트에 맞게 Pending.  
Initial Vector로 F함수를 처리할거다.  

![Message Pending](https://zemalee.github.io/images/Computer_Security/04_SHA1024_02.png)  

512비트 80개로 쪼개서 각 라운드를 진행한다.  

![Message Pending](https://zemalee.github.io/images/Computer_Security/04_SHA1024_03.png)  

각 라운드는 덧셈연산과 Major연산으로 빠르게 처리한다.  

다 외우거나 할 필요는 없어보인다. 넘어간다.  

## Keyed Hash Function - HMAC

### 간단한 Keyed-Hash 정보들  

왜 Keyed가 필요한가? = 인증에 이용하기 위함.  

간단하게 생각해보면  
Keyed Hash = Hash( Key | Message ).  

이런식으로 concat하면 공격자는 Message를 바꿔가면서 hash가 어떻게 출력되는지 Model이 깔끔하게 나와버린다.  
즉, Hash의 안전도만 남고 Keyed가 의미가 없어질 우려가 있다.

### HMAC

간단하게 말하면, 계속 Key값을 넣어서 바꿔서 찾아내기 힘들게 하는 방법이다.  

![Message Pending](https://zemalee.github.io/images/Computer_Security/05_HMAC_overview.png)  

Key를 input-padding한 값(초기값)을 넣고 돌린다.  
그 후, output을 또 Pending해서 넣는다.  
그 결과, **Key값과 출력이 직접적으로 연관이 없게 된다**  

이 또한 **외울 필요가 없다고 한다**.  

---  

# CH13 Digital Signature

## OverView

메세지 인증은 양자 사이에서 제 3자의 공격을 안전하게 하는 데 한계가 있다. 보내는 사람이 바뀌어버리면?? 대책이 없더라!!  

따라서, 전자서명은 보내는사람, 서명한 날짜/시간을 가지고 있어야 한다.  

디지털 서명을 아주 간단하게 보면 아래와 같다.  

![일반적인 디지털 서명 과정](https://zemalee.github.io/images/Computer_Security/06_General_Digital_Signature.png)  

하지만 Message를 통째로 넣기 귀찮고 시간도 많이 걸리니까 Message를 Hash화 한 후 서명하는 방법으로 사용하는 편이다.  

## 공격 기법

* Key-only Attack  
	공개키만 알고 있는... 존나어려운 공격

* Known Message Attack  
	어떤내용의 메세지를 암호화한건지 아는 경우.(안녕?을 서명했다.라던지..)

* Generic chosen message attack  
	공격자가 **임의**의 메세지에 대한 서명을 만들어 낼 수 있는 경우의 공격.

* Directed Chosen Message Attack  
	Message를 공격자 의도대로 바꾼 서명값을 알아낼 수 있는 공격.

* Adaptive Chosen Message Attack  
	메시지와 서명 쌍을 선택할 수 있게 된다.  
	Adaptive한 것을 만들어 주는 것을 Oracle이라 한다.  
	**공격자 입장에서 가장 쉬운 공격기법**

## 디지털 서명이 가져야 하는 패턴  

bit pattern으로 나와야 한다.  
서명 및 검증은 쉬워야 한다.  
공격하기는 어려워야 한다.  

## Arbitrated Digital Signatures

Sender & Receiver가 직접 소통하는건 위험하다. 제 3자가 나서야 한다.  

### ElGamal Digital Signature

디피헬만 알고리즘으로 M, S1, S2를 보내는 방법.  

** 송신 **  

```  

1. 비밀키 x를 하나 선택한다(1~q-1)  

2. x를 기반으로 공개키 Ya = a^{x} mod q 를 생성한다.  

3. 메시지 M을 해싱한다. (m = H(M))  

4. Generator g를 선택한다. (PPT에는 K로 표기)  

5. S1 = a^{k} mod q  

6. K의 inverse(q-1공간)를 구한다. (K^{-1}  

7. S2 = K^{-1} * (m - (x*S1)) mod (q-1)  

```
** 수신 **  

받은 값 S1, S2를 통해 계산한 값과, 공개키와 해쉬값으로 계산하는 값을 비교하여 **인증**, **서명**이 확인된다.

```  

V1 = a^{m} mod q  :: 공개키와 메세지해쉬값으로 계산  

V2 = Ya^{S1} * S1^{S2} mod q :: 받은 값으로 계산  

V1 == V2 ? 제대로왔군 : 변조됐군.  

```  

### Schnorr Digital Signature

서명이 짧다.. 정도만 알면 된답니다.  

---  

# CH14 Authentication X509 Certificate

CA : 인증기관.. 이라고 알고 아래를 이해하자.  

어떤 사람의 공개키 및 아이디를 CA가 확인해주는 방법.  

CA가 서명해서 공개키로 확인할 수 있게 토큰을 줌.  

★★★ **표기법**  
CA << A >> 는 CA가 A의 공개키를 서명해줬다는 의미.  

![인증 체인](https://zemalee.github.io/images/Computer_Security/07_CA_Hierarchy.png)  

내가 어떻게 외국에 있는 이름 모를 회사의 공개키를 믿고 메세지를 보낼수 있는가~? 에 대한 Tree.  

```  
(안읽어도됨)  
나 : A, 확인하고자 하는 기관 : B  
X는 날 인증해준 착한 기관이다.  
X를 인정해준 W는 착한 기관이다.  
W를 인정해준 V는 착한 기관이다.  

V는 착한놈인데, Y를 인정하네? Y도 착하다.  
Y는 착한놈인데, Z를 인정하네? Z도 착하다.  
Z는 착한놈인데, B를 인정하네?  

오호! B는 믿을만한 놈인가보다.  
```

**Nonce** : 랜덤한 값으로, Replay 공격을 방지함.  

## ★★★ 1,2,3-Way Authentication

### One-Way Authentication

![One-way Authentication](https://zemalee.github.io/images/Computer_Security/08_One_way.png)  

A가 B를 timestamp, nonce와 함께 서명해주는 방식  

### Two-way Authentication

![Two-way Authentication](https://zemalee.github.io/images/Computer_Security/09_Two_way.png)  

A가 B를, B도 A를 인증하는 방식으로,  
rA(nonce)를 B가 되돌려줌으로 인해  
"방금 내가 보낸거에 대한 인증값이구나"를 확인할 수 있음.

### Three-way Authentication

![Three-way Authentication](https://zemalee.github.io/images/Computer_Security/10_Three_way.png)  

A가 B에게 준걸 B가 확인하고, 자기도 넌스를 하나 더 실어서 줌.  
A는 B가 만든 Nonce를 잘받았다고 알려주는 방식.

---  

# CH15 User Authentication

## Authentication Protocol

User Authentication은 여러개가 있다.  
* knows : 지식 기반  
	ex) 비밀번호, PIN번호 입력 등  

* Possesses : 소유 기반  
	ex) 열쇠, 토큰, 스마트카드 등  

* is(static biometrics) : 바이오 기반  
	ex) 지문, 홍채인식 등  

* does(dynamic biometrics) : 행위 기반  
	ex) 음성, 서명 등

**Replay attacks**

* Simple Replay  
	그냥 다시 한번 시도해보기.  
* Repetition that can be logged  
	허용시간 범위 내에서 재전송해보기.  
* Repetition that cannot be detected  
	원본은 정지된 상태고, 재전송용 메세지만 도착하는 경우  
* Backward Replay without modification  
	수정 없이 역방향 재전송.(그냥 온걸 다시 보내는거래요)  

**방어방법들...**

* Sequence Number  
	생각보다 취약하기 때문에 잘 안쓴다.

* TimeStamp  
	전송 시점이 잘못된 걸로 눈치챌 수 있음.!!

* Challenge / Response  
	(확실X) Nonce로 그때그때 업데이트 하면서 메시지 주고받는 방법  

## ★★★ Needham-Schroeder Protocol

**KDC : Key Distribute Center**를 알고 아래를 이해하자!!  

![Needham-Schroeder Protocol](https://zemalee.github.io/images/Computer_Security/11_Needham.png)  

1) A->KDC  
	나는 A야. B랑 통신하고싶어.  
2) KDC->A  
	비밀키, B아이디, 니가보낸 넌스 여기있어.  
	B만 열어볼 수 있게 토큰도 같이 달아줄께  
	(Token : E_{kb}[Ks || AID]  
3) A->B  
	안녕 B야, 이거 KDC가 너 주래.  
4) B->A  
	(비밀키로) 내꺼 받으면 연락줘~  
5) A->B  
	(비밀키로) 니가 보낸거 좀 수정했어~  

참고) 과정 5에서 함수화하는 이유는 Replay attack 방지를 위함!!  

## ★ Kerberos

간단하게 보면 이렇다.  

![Kerberos](https://zemalee.github.io/images/Computer_Security/12_Kerberos.png)  

한 단계씩 보자.

![Kerberos_1,2](https://zemalee.github.io/images/Computer_Security/13_Kerberos_12.png)  


![Kerberos_3,4](https://zemalee.github.io/images/Computer_Security/13_Kerberos_34.png)  


![Kerberos_5,6](https://zemalee.github.io/images/Computer_Security/13_Kerberos_56.png)  

에라이... 큰거 한 번 더 보면서 생각해봐요

![Kerberos_OverView](https://zemalee.github.io/images/Computer_Security/14_Kerberos_OV.png)  

그냥 순서만 잘 생각하면 안어려움...

---  

# CH19 ComputerSecurity MaliciousSW

잉... 뭐하는지 모르겠다 이건